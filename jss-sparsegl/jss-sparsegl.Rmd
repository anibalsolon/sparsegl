---
documentclass: jss
author:
  - name: Daniel McDonald
    affiliation: |
      | University of British Columbia
    address: |
      | Department of Statistics
      | Vancouver, BC Canada
    email: \email{daniel@stat.ubc.ca}
    url: \url{https://dajmcdon.github.io/}
  - name: Xiaoxuan Liang
    affiliation: 'University of British Columbia \AND'
    address: |
      | Department of Statistics
      | Vancouver, BC Canada
  - name: Aaron Cohen
    affiliation: 'Indiana University'
    address: |
      | Department of Statistics
      | Bloomington, IN USA
title:
  formatted: "Estimating Sparse Group Lasso with the \\pkg{sparsegl} R Package"
  # If you use tex in the formatted title, also supply version without
  plain:     "Sparse Group Lasso with \\pkg{sparsegl}"
  # For running headers, if needed
  short:     "\\pkg{sparsegl}: Sparse Group Lasso"
abstract: >
  The sparse group lasso is a high-dimensional regression technique that is
  useful for problems whose covariates have a naturally grouped structure, and
  where sparsity is encouraged at both the group and individual covariate
  level. In this paper we discuss two algorithms for this optimization
  problem, as well as their implementation in Fortran as part of a new R
  package. This R package is an advance over existing packages, as it is the
  only one that solves this problem in a sufficiently fast computation time
  for truly high-dimensional situations.
keywords:
  # at least one keyword must be supplied
  formatted: [keywords, not capitalized, "\\proglang{Java}"]
  plain:     [keywords, not capitalized, Java]
preamble: >
  \usepackage{amsmath}
  \input{jss-sparsegl-preamble}
output: rticles::jss_article
bibliography: [sparsegl.bib, pkgs.bib]
---

```{r, setup, include=FALSE}
options(prompt = 'R> ', continue = '+ ')
# Add any packages we want to cite to the list below. Don't edit the bib
# manually, or changes will be overwritten. Add other references to
# `sparsegl.bib`
# 
# Note: tags are R-<pkg>
knitr::write_bib(c("devtools", "knitr", "testthat", "usethis", "rticles",
                   "SGL","gglasso", "microbenchmark", "ggplot2"),
                 file = "pkgs.bib")
```

# Introduction

* Introduction to the package what does it do. 1-2 paragraphs.

* Description of related packages and what they do and don't do. 3-4 paragraphs.

* Paragraph outlining the rest of the paper.

Linear regression is the most common type of statistical model for fitting and prediction. When solving the high-dimensional learning problems, adding a weighted regularization component helps to reduce the chances of overfitting and improve the model performance to unseen data. More specifically, the lasso is an $l1$-based penalty, which encourages the sparsity in the solution and brings about significant computational advantages. Group-lasso penalty is an enhanced approach to variable selection, preserving the grouping structure but only achieving the sparsity at the group level. To attain the sparsity at both group and individual feature levels, the sparse group-lasso penalty is introduced, namely a linear convex combination of the lasso penalty and group lasso-penalty. In this case, the package is developed regarding the class of sparse group-lasso problems, where the objective function is the sum of mean squared deviation and the sparse group-lasso penalty. This package focuses on finding the optimal solutions to the sparse group-lasso penalized learning problems at a sequence of regularization parameters, and more importantly, how to improve the computational efficiency in the meanwhile.

There are already two other existing \pkg{R} packages that perform group lasso, \pkg{gglasso} and \pkg{SGL}. Both of them are with strengths but also certain limitations to some extent: the SGL package has sparsity, but does direct coordinate descent and does not apply a heuristic like the strong rule, so it does not take advantage of such a computational speedup. Because of this, \pkg{SGL} is too slow to be of use in analyzing the high-dimensional problems that occur commonly, for example in genetic applications. The \pkg{gglasso} package, on the other hand, incorporates such a rule and is computationally fast, but does not incorporate within-group sparsity (i.e., it performs group lasso, not sparse group lasso). When this package is used on a grouped dataset, the solution will have some active groups and some inactive, but within an active group, generally all the coefficients will be nonzero. Our contribution, then, is to provide a package that performs sparse group lasso, and is faster than existing algorithms. The algorithms for this package are written in Fortran, and are based on the algorithm from the gglasso package.

In section 2, we describe the algorithm in detail, paying particular attention to the strong rule. In section 3, we show how to use the package, running through an example with simulated data. In section 4, we compare our package to the other existing group-lasso packages, and also compare the two variants of our algorithm with each other. We make a summary and discussions in section 5, and make promising proposals for potential future research as well.


## Code formatting instructions (remove this section later)

In general, don't use Markdown, but use the more precise LaTeX commands instead:

* \proglang{Java}
* \pkg{plyr}

One exception is inline code, which can be written inside a pair of backticks (i.e., using the Markdown syntax).

If you want to use LaTeX commands in headers, you need to provide a `short-title` attribute. You can also provide a custom identifier if necessary. See the header of Section \ref{r-code} for example.

### \proglang{R} code {short-title="R code" #r-code}

Can be inserted in regular R markdown blocks.

```{r}
x <- 1:10
x
```

### Features specific to \pkg{rticles} {short-title="Features specific to rticles"}

* Adding short titles to section headers is a feature specific to \pkg{rticles} (implemented via a Pandoc Lua filter). This feature is currently not supported by Pandoc and we will update this template if [it is officially supported in the future](https://github.com/jgm/pandoc/issues/4409).
* Using the `\AND` syntax in the `author` field to add authors on a new line. This is a specific to the `rticles::jss_article` format.

### Additional formatting help

[bookdown](https://bookdown.org/yihui/rmarkdown-cookbook/bibliography.html)




# Methodology, estimation and prediction

The lasso is ``a regression analysis method that performs both variable selection and regularization,'' which uses an $l1$ penalty \citep{tibshirani1996regression} to select a subset of predictors to be nonzero. The minimization problem is of the form
\[
\min_{\boldsymbol{\beta}} \frac{1}{2}\norm{\mathbf{y}-\mathbf{X}\boldsymbol{\beta}}_2^2 + \lambda \norm{\boldsymbol{\beta}}_1,
\]
where $X$ is an $n$-by-$p$ data matrix, $\beta$ is the unknown coefficient vector, and $\lambda$ is a hyperparameter that enforces the regularization/variable selection. In this problem it is assumed that the response $y$ is linearly related to the predictors (the columns of the data matrix $X$), with the goal being to estimate the coefficient vector $\beta$ responsible for this linear relationship. In general it returns a solution with some nonzero entries in the $\beta$ vector, and the rest zero.

A variant of this, the group lasso \citep{yuan2006model} is appropriate when there is a natural grouping structure for the coefficients; that is, we assume that the vector of coeffiecients is partitioned into groups, or subvectors, and, by analogy with regular lasso regression, only a few of the groups are active, i.e., have nonzero coefficients. The group lasso thus performs regularization that has the effect of discarding groups of predictors rather than the predictors themselves; it is of the form 
\[
\min_{\boldsymbol{\beta}}\frac{1}{2}\norm{\mathbf{y}-\sum_{l=1}^m\mathbf{X}^{(l)}\boldsymbol{\beta}^{(l)}}_2^2 + \lambda\sum_{l=1}^m\sqrt{p_l}\norm{\boldsymbol{\beta}^{(l)}}_2.
\]
Note that the grouping structure is explicitly stated in the above equation: the vector of coefficients, $\boldsymbol\beta$, is thought of as a concatination of the coefficient subvectors of the various groups $\boldsymbol\beta^{(l)}$, and similarly the data matrix $\mathbf{X}$ is the concatination of submatrices, each submatrix $\mathbf{X}^{(l)}$ being composed of the columns that correspond to the particular group. Thus the first part of the equation, $\mathbf{y}-\sum_{l=1}^m\mathbf{X}^{(l)}\boldsymbol\beta^{(l)}$, is identical to the more simply-written equation $\mathbf{y}-\mathbf{X}\boldsymbol\beta$, but is written with this partition in mind. 

The second part of the equation, however---$\sum_{l=1}^m\sqrt{p_l}\norm{\boldsymbol\beta^{(l)}}_2$---is different than the corresponding part in the original lasso equation. Rather than being an $l1$-norm of the vector $\boldsymbol{\beta}$, it is a sum of the (non-squared) $l2$-norms of the coefficient vectors of the various groups. It is interesting to note that it is the non-differentiability of this expression at $0$ that accounts for the group-discarding property of the problem, similar to how the $l1$-norm's non-differentiability at 0 is responsible for the discarding property of coefficients in the original lasso. 

As with the original lasso equation, there is only a single tuning parameter $\lambda$, whose value determines the strength of regularization. Within the second summation are the relative weights of the groups, $p_l$, though these are usually determined by the size of the corresponding groups, and so in the rest of this paper this notation is suppressed from the equations.

Finally, in a group-structured problem as above, it may be desirable to enforce sparsity, not only among the groups, but also within the groups. The sparse group lasso \citep{simon2013sparse} does this by solving the following minimization problem
\begin{equation}
  \label{eq:sparsegl}
\min_{\boldsymbol\beta}\frac{1}{2}\norm{\mathbf{y}-\sum_{l=1}^m\mathbf{X}^{(l)}\boldsymbol\beta^{(l)}}_2^2 + (1-\alpha)\lambda\sum_{l=1}^m||\boldsymbol\beta^{(l)}||_2+\alpha\lambda||\boldsymbol\beta||_1.
\end{equation}
This equation is very similar to that of the group lasso, and in fact one sees that the only difference is that it adds a second regularization term, the overall $l1$-norm of the full $\boldsymbol\beta$ vector, which we first saw in the original lasso formulation.  There is now a second tuning parameter $\alpha$, which controls the relative emphasis of intra- vs inter- sparsity in the predictors.

The sparse group lasso, like the other two lassos, does not have a closed form solution and thus relies on computational algorithms, which may be very intensive for large datasets and/or many values of $\lambda$. The rest of this paper therefore concerns the mitigation of this issue, in particular the following question: if we are solving the sparse group lasso, not for a single value of the tuning parameter $\lambda$ but a whole parameter space---in this context, a range of values $(\lambda_1,\dots \lambda_S)$--- can we shorten the total computational time by making use of the already-computed solution at previous $\lambda$'s in the parameter space to speed up computation at a given $\lambda$?

In this paper we make use of a heuristic called the Strong Rule \citep{tibshirani2012strong} to help solve this problem, with some success. The strong rule uses the solution at the previous $\lambda_{s-1}$ to predict which groups will remain inactive upon solution at the current $\lambda_s$, and discards those groups before entering into the algorithm. If a significant number of groups are thrown out before entering the algorithm, convergence time can improve significantly.

The \texttt{R} package we have create has two algorithms, both using the strong rule, but in slightly different ways: the \textbf{three-step algorithm} and the \textbf{four-step algorithm}. Although they perform similarly for the simulated data set used in later sections of this paper, it is suspected that they will each be useful for different scenarios, depending on the size of the data, size of the predictors, and the true underlying group structure. 

## Overview of the algorithm

There is no closed-form solution to the optimization problem in \autoref{eq:sparsegl} above, so we need a numerical algorithm to find the optimal solution. The problem defined by \autoref{eq:sparsegl} is convex, since the expression is a sum of convex functions and the feasable set is convex, so there is an optimal solution, and a variety of methods may be used one.

Our package has two different algorithms to accomplish this, which we refer to as the \textbf{three-step} and \textbf{four-step} algorithms. The general framework for both of our algorithms is based on a block-wise coordinate descent algorithm (see \citep{yang2015fast, simon2013sparse}). What this means is that we loop over the groups and, for a given group, update only those variables while holding all other groups constant. In particular, we will use a majorization-minimization coordinate descent scheme; the term 'majorization' comes from the idea that, instead of using the exact equation to determine the step size and direction in every update step, we update according to a simpler expression than \autoref{eq:sparsegl} that majorizes, or bounds from above, the expression we want to solve for. This is explained in more detail in the following paragraph.

For the rest of this section, we will focus on a particular group $k$. We hold the coefficients for all other groups fixed, and find an appropriate update step for group $k$. We note here that, because the loss function in \autoref{eq:sparsegl} is differentiable and the penalty terms are convex and separable (i.e., they can be decomposed into a sum of functions each only involving a single group), a coordinate descent algorithm is guaranteed to converge to a global optimum \citep{tseng2001convergence}.

To begin with, we will introduce some notation. Let 

\[
\mathbf{r}_{(-k)} = \mathbf{y} - \sum_{l \neq k} \mathbf{X}^{(l)} \boldsymbol\beta^{(l)}
\]
be the partial residual of $y$, where all the group fits besides that of group $k$ are subtracted from $\mathbf{y}$. Since all groups besides group $k$ are held fixed, we don't need to consider the penalty terms corresponding to those fixed groups. So what we are really interested in minimizing is the following:

\begin{equation}
	\label{eq:sparsegroupk}
\frac{1}{2n} \norm{\mathbf{r}_{(-k)}-\mathbf{X}^{(k)}\boldsymbol\beta^{(k)}}_2^2 + (1-\alpha)\lambda \norm{\boldsymbol\beta^{(k)}}_2 + \alpha \lambda \norm{\boldsymbol\beta^{(k)}}_1. 
\end{equation}
For ease of notation, we will suppress the superscript $(k)$ from $\boldsymbol\beta^{(k)}$, with the understanding that we are really referring to only the $k$-th group of the coefficient vector. We will also define, using these terms, the unpenalized loss function

\[
\ell (\mathbf{r}_{(-k)}, \boldsymbol\beta) = \frac{1}{2n}\norm{\mathbf{r}_{(-k)} - \mathbf{X}^{(k)}\boldsymbol\beta}_2^2, 
\]
so that our optimization problem for the $k$-th group becomes $\ell (\mathbf{r}_{(-k)},\boldsymbol\beta) + (1-\alpha)\lambda\norm{\boldsymbol\beta}_2 + \alpha \lambda \norm{\boldsymbol\beta}_1$, and we are interested in finding an optimal value, $\hat{\boldsymbol\beta}$.

Any global minimum is determined by the subgradient equation, which is similar to a first-derivative test for minima, except the $\norm{\cdot}_2$ and $\norm{\cdot}_1$ penalty terms are non-differentiable at $0$; because of this, the (sub)differential for each coordinate in $\boldsymbol\beta$ (i.e., $\boldsymbol\beta^{(k)}$) is not a single value, but a range of possible values. For \autoref{eq:sparsegroupk} above, taking the subdifferential and setting equal to zero gives us the following condition that the minimum $\hat{\boldsymbol\beta}$ needs to satisfy: 

\begin{equation}
  \label{eq:subgrad}
\frac{1}{n}\mathbf{X}^{(k)\top}(\mathbf{r}_{(-k)} - \mathbf{X}^{(k)}\boldsymbol\beta) = (1-\alpha)\lambda \mathbf{u} + \alpha \lambda \mathbf{v},
\end{equation}
where $\mathbf{u}$ is the subgradient of $\norm{\boldsymbol\beta}_2$ and $\mathbf{v}$ is the subgradient of $\norm{\boldsymbol\beta}_1$. The first is defined to be $\frac{\boldsymbol\beta}{\norm{\boldsymbol\beta}_2}$ if $\boldsymbol\beta$ is a nonzero vector, and is any value in the set $\{\mathbf{u} : \norm{\mathbf{u}}_2 \leq 1 \}$ otherwise; the second, $\mathbf{v}$, is defined coordinate-wise as $v_j = \text{sign}(\beta_j)$ if $v_j \neq 0$, and is any value $v_j \in \{v_j : |v_j| \leq 1 \}$ otherwise.


At this point, it is possible to use \autoref{eq:subgrad} to derive an update step and develop a cyclical coordinate-wise algorithm, but it is too computationally expensive, involving repeated large-matrix multiplication (\citep{simon2013sparse}); instead we use the majorization-minimization idea discussed above.

Since the unpenalized loss $\ell (\mathbf{r}_{(-k)}, \boldsymbol\beta)$ is a quadratic function in $\boldsymbol\beta$, it is equal to its second order Taylor expansion about any point $\boldsymbol\beta_0$ in the parameter space---indeed, this is the definition of a function being quadratic. We thus start with the following equality for any given $\boldsymbol\beta_0$ (recall that $\boldsymbol\beta_0 = \boldsymbol\beta_0^{(k)}$):  

\begin{equation}
\forall \boldsymbol\beta,\ \ell(\boldsymbol\beta) = \ell(\boldsymbol\beta_0)+(\boldsymbol\beta - \boldsymbol\beta_0)^\top\nabla \ell(\boldsymbol\beta_0)+\frac{1}{2}(\boldsymbol\beta - \boldsymbol\beta_0)^\top H (\boldsymbol\beta - \boldsymbol\beta_0),
\label{eq:TaylorExp}
\end{equation}

where the gradient $\nabla \ell$ is the first total derivative of $\ell$ (evaluated at $\boldsymbol\beta_0$) and $\mathbf{H}$, the Hessian, is the second total derivative. Note that we have again suppressed notation, $\ell(\boldsymbol\beta) = \ell(\mathbf{r}_{(-k)},\boldsymbol\beta)$, since $\boldsymbol\beta = \boldsymbol\beta^{(k)}$ is the only variable. Recall that $\nabla$ is the vector of first partial derivatives of $\ell$ with respect to each coordinate of $\boldsymbol\beta$, evaluated at $\boldsymbol\beta_0$, and $\mathbf{H}$ is a $p$-by-$p$ matrix of mixed partial derivatives of $\ell$. In this particular case, a short computation shows that the Hessian is simply written in terms of $\mathbf{X}$: $\mathbf{H} = \mathbf{X}^\top \mathbf{X}$.

The matrix $\mathbf{X}$ is, for the problems we are interested in solving, very large, and so computing $\mathbf{X}^\top \mathbf{X}$, storing it in memory, and inverting, is going to be an issue, especially since we will be doing update steps many times. What we can do, and will do, is replace this matrix with a much simpler one, $t\mathbf{I}$, a diagonal matrix with the value of $t$ selected to be such that this dominates the Hessian (in the sense that $t\mathbf{I} - \mathbf{H}$ is positive definite). For our algorithm we choose the largest eigenvalue of the Hessian and use that for $t$. We get the following inequality:



\begin{equation}
\forall \boldsymbol\beta,\boldsymbol\beta_0,\ \ell(\boldsymbol\beta) \leq \ell(\boldsymbol\beta_0)+(\boldsymbol\beta - \boldsymbol\beta_0)^\top\nabla \ell(\boldsymbol\beta_0)+\frac{1}{2t}(\boldsymbol\beta - \boldsymbol\beta_0)^\top  (\boldsymbol\beta - \boldsymbol\beta_0).
\label{eq:dominate}
\end{equation}

We take the original minimization problem (\autoref{eq:sparsegroupk}) and replace the loss $\ell$ with the right-hand side of \autoref{eq:dominate}. Thus \autoref{eq:sparsegroupk} is now dominated (majorized) by the following expression
\begin{equation}
\label{eq:Meq}
M(\boldsymbol\beta) = \ell(\boldsymbol\beta_0)+(\boldsymbol\beta - \boldsymbol\beta_0)^\top\nabla \ell(\boldsymbol\beta_0)+\frac{1}{2t}\norm{\boldsymbol\beta_0-\boldsymbol\beta}_2^2+ (1-\alpha)\lambda\norm{\boldsymbol\beta}_2+\alpha\lambda\norm{\boldsymbol\beta}_1,
\end{equation}
which no longer involves the large matrix multiplication that using the original loss function would have confronted us with. 

The optimal value $\hat{\boldsymbol\beta}$ for $M(\boldsymbol\beta)$ is determined by its subgradient equation, which is similar to that of \autoref{eq:subgrad}:

\begin{equation}
\frac{1}{t} (\boldsymbol\beta - (\boldsymbol\beta_0 - t\nabla \ell)) +(1-\alpha)\lambda \mathbf{u} + \alpha \lambda \mathbf{v} = 0,
\end{equation}
with $\mathbf{u}$ and $\mathbf{v}$ as before. If we solve this for $\boldsymbol\beta$ in terms of $\boldsymbol\beta_0$, paying close attention to the conditions for the subdifferentials when $\boldsymbol\beta$ is and isn't $0$, we get the following equation:
\begin{equation}
\hat{\boldsymbol\beta} = U(\boldsymbol\beta_0) =
\left(1-\frac{t(1-\alpha)\lambda}{\norm{S(\boldsymbol\beta_0-t\nabla \ell(\boldsymbol\beta_0),\ t\alpha\lambda)}_2}\right)_+ S(\boldsymbol\beta_0-t\nabla \ell(\boldsymbol\beta_0),t\alpha\lambda),
\label{eq:updateStep}
\end{equation}
where $S$ is the coordinate-wise soft threshold operator, defined by a vector $\boldsymbol\gamma$ and scalar $b$ according to
\begin{equation}
\label{softthresh}
(S(\boldsymbol\gamma,b))_j = \text{sign}(\gamma_j)(|\gamma_j| - b)_+,
\end{equation}
i.e., for each coordinate in the vector, it shrinks that coordinate in magnitude by the amount $b$, and sets it to zero if the magnitude of that coordinate was smaller than $b$ to begin with.



\autoref{eq:updateStep} defines the update step at a given group $k$, via $\boldsymbol\beta \leftarrow U(\boldsymbol\beta)$. At a point $\boldsymbol\beta_{old} = \hat{\boldsymbol\beta}^{(k)}_{old}$, we find the convex function $M$ that majorizes the objective function--centered at that $\boldsymbol\beta_{old}$--and choose the new value of beta to be the minimizer of majorized function, $\boldsymbol\beta_{new} = U(\boldsymbol\beta_{old})$. This update step has the advantage that it is easy to compute, and is guaranteed to converge to the optimum $\hat{\boldsymbol\beta} = \hat{\boldsymbol\beta}^{(k)}$ for that given group.  


By examining the update step we see that it is possible for the whole group to be set to zero (made inactive) because of the threshold operator $()_+$ in the first part of the expression, and it is possible also for individual components of $\boldsymbol\beta^{(k)}$ to be zeroed out from the coordinate-wise threshold $S()$. From this it is seen that this update step tends to enforce sparsity at both the group and individual level.

Both of the algorithms in the \pkg{sparsegl} package use the update step $U$ in \autoref{eq:updateStep}, iterating over all the groups and performing one update per pass. Since the partial residual $\mathbf{r}_{(-k)}$ is used in $U$ (via $\ell$), we note that, for a given group $k$ at a given point in the cycle, the update $\boldsymbol\beta^{(k)} \leftarrow U(\boldsymbol\beta^{(k)})$ uses the new values of $\boldsymbol\beta^{(1)}, \dots \boldsymbol\beta^{(k-1)}$ and the old values for the subsequent $\boldsymbol\beta^{(k+1)},\dots \boldsymbol\beta^{(m)}$.

Because the optimization problem is convex, with differentiable loss and separable penalty, it can be shown that this type of blockwise coordinate descent algorithm is guaranteed to converge to the optimal solution for the full vector $\hat{\boldsymbol\beta}$. That is, it does not get `stuck' at any inflection points or local minima. Therefore, if that was all the algorithm did, there would be no need to check the KKT conditions for optimality. 

However, our algorithms both make use of the sequential strong rule, a heuristic that predicts, before computation, which groups will remain inactive, and discards them; this results in significant computational savings, but because this pre-processing prediction is not always correct, we will need to do a KKT check \citep{boyd2004convex} after convergence to make sure the initial prediction was accurate. This is described in the next section.

## KKT Check and the Strong Rule

As mentioned above, the strong rule \citep{tibshirani2012strong} is easy and fast to perform, discarding large numbers of predictors before computation, but it is not guaranteed to be correct, so it becomes necessary to double-check the solution after convergence, to make sure active groups were not accidentally discarded. 

The version of the strong rule used here is called the \textbf{sequential strong rule}; it makes use of the fact that we are solving for a sequence $\{\lambda_1 \geq \lambda_2 \geq \dots \ ,\ \lambda_S\}$ of lambda parameters, rather than a single value. At each $\lambda_s$, we rely on the fact that we have solved the problem for the previous $\lambda_{s-1}$, and use this information to quickly discard many predictors. Without loss of generality, for the rest of this section assume that the problem has already been solved for $\lambda_{s-1}$.



The motivation for the strong rule comes from the KKT stationarity condition, which is similar to the first derivative test for minima \citep{boyd2004convex}. Explicitly, this is the condition that the subdifferential equations (see \autoref{eq:subgrad}) are satisfied at the proposed minimum $\hat{\boldsymbol\beta} =\hat{\boldsymbol\beta}(\lambda_s)$. This is the necessary and sufficient condition for a global optimum. Note that we will be emphasizing the dependence of $\hat{\boldsymbol\beta},\mathbf{r}_{(-k)}$, and so forth, on $\lambda$ in this section.
 
From \autoref{eq:subgrad} we derive an inequality that is equivalent to the KKT stationarity condition in the case that $\hat{\boldsymbol\beta}^{(k)}=0$. Because the algorithm is guaranteed to converge to the optimum for all groups on which it is run, we only need to check the condition for the discarded groups, i.e., those that we have preassigned $\hat{\boldsymbol\beta}^{(k)} = 0$ (at a given $\lambda$). 

First, if $\hat{\boldsymbol\beta}^{(k)}=0$ then the subgradient equations reduce to the following:

\begin{equation}
\label{eq:subgradreduced}
\mathbf{X}^{(k)\top}\mathbf{r}_{(-k)}/n - \alpha \lambda \mathbf{v} = (1-\alpha) \lambda \mathbf{u},
\end{equation}
where $\mathbf{u}$ and $\mathbf{v}$ are the subdifferentials of $\norm{\boldsymbol\beta^{(k)}}_2$ and $\norm{\boldsymbol\beta^{(k)}}_1$, as in section 2.1. We claim that if the following inequality

\begin{equation}
\label{eq:kkt}
\norm{S(\mathbf{X}^{(k)\top}\mathbf{r}_{(-k)}/n,\ \alpha\lambda)}_2 \leq (1-\alpha)\lambda
\end{equation}
is satisfied (with $S$ the soft-threshold operator from section 2.1), then $\hat{\boldsymbol\beta}^{(k)}=0$ is the optimum for that group at that particular lambda. In other words, this inequality is equivalent to the KKT stationarity condition for inactive groups.

The proof is as follows: denote $\boldsymbol\gamma = \mathbf{X}^{(k)\top}\mathbf{r}_{(-k)}/n$, and define $v_j = \text{sign}(\gamma_j)$ if $|\gamma_j| > \alpha \lambda$, and $v_j = \frac{\gamma_j}{\alpha \lambda}$ otherwise. Then 
\[
\boldsymbol\gamma - \alpha \lambda \mathbf{v} = S(\boldsymbol\gamma,\alpha \lambda).
\]
Next, define $\mathbf{u} = S(\boldsymbol\gamma,\alpha \lambda)/(1-\alpha)(\lambda)$. From these two definitions it follows that \autoref{eq:subgradreduced} is satisfied, but not necessarily by elements of the subdifferentials. But if \autoref{eq:kkt} is also satisfied, then $u$ is a subgradient of $\norm{\boldsymbol\beta^{(k)}}_2$, and $\boldsymbol{v}$ a subgradient of $\norm{\boldsymbol\beta^{(k)}}_1$, evaluated at $\boldsymbol\beta^{(k)}=0$.

We have derived the KKT condition for the $k$-th group to be $0$. We will now derive and explain the strong rule, which is based on this inequality. At this point it will be helpful to make explicit the dependence of these expressions on $\lambda$. First, for each group $k$ we define a function of $\lambda$:

\begin{equation}
c_k(\lambda) = S(\mathbf{X}^{(k)\top}\mathbf{r}_{(-k)}(\lambda)/n,\ \alpha\lambda).
\end{equation}
So for example \autoref{eq:kkt} becomes $\norm{c_k(\lambda)}_2 \leq (1-\alpha)\lambda$. There is a different function for every group $k$. Note that, since $\mathbf{r}_{(-k)}$ involves $\hat{\boldsymbol\beta}$, we needed to have actually solved the optimization problem at $\lambda$ in order to compute $c_k(\lambda)$.

It is natural to consider the properties such a function would have. These functions are continuous, for example, as the solution to the optimization problem \autoref{eq:sparsegl} varies continuously with its tuning parameter $\lambda$. We are now going to make an assumption about $c_k$, which seems unintuitive at first, and in fact is not always true, but is true often enough to be useful: we assume that $c_k(\lambda)$ is $(1-\alpha)$-Lipschitz, ie., that
\begin{equation}
\label{eq:lipschitz}
\forall \lambda,\ \lambda^{\prime}\ \  \ \norm{c_k(\lambda)-c_k(\lambda^{\prime})}_2 \leq (1-\alpha)\norm{\lambda - \lambda^{\prime}}_2.
\end{equation}
This is essentially saying that $c_k$ is not only continuous but does not vary 'too fast'; it is equivalent to saying that the function is differentiable almost everywhere and has bounded derivative.


We can finally define the \textbf{strong rule} check for discarding groups. Assume that the optimization problem has been solved for $\lambda_{s-1}$; then if the inequality
\begin{equation}
\label{eq:strong}
\norm{c_k(\lambda_{s-1})}_2 \leq (1-\alpha)(2\lambda_s - \lambda_{s-1})
\end{equation}
holds, then we discard group $k$ from the problem, before solving for $\lambda_s$. That is to say, when we move from $\lambda_{s-1}$ to $\lambda_s$, we first run this check on all groups, using the previously computed solution for $\hat{\boldsymbol\beta}(\lambda_{s-1})$, and then move on to coordinate descent, using only those groups that failed this inequality.

This discarding rule is fast, using the previously computed solution and a simple inequality, and in practice it tends to accurately discard large numbers of groups. The reason why it works is as follows: assuming the Lipschitz condition on $c_k(\lambda)$, then if the strong rule is satisfied for $\lambda_s$, we get by the triangle inequality that
\begin{align*}
\norm{c_k(\lambda_s)}_2 &\leq \norm{c_k(\lambda_s) - c_k(\lambda_{s-1})}_2 + \norm{c_k(\lambda_{s-1})}_2 \\
&\leq (1-\alpha)(\lambda_{s-1} - \lambda_s) + (1-\alpha)(2\lambda_s - \lambda_{s-1})
=(1-\alpha)\lambda_s,
\end{align*}
which is exactly the KKT condition required for $\hat{\boldsymbol\beta}^{(k)}(\lambda_s) = 0$, \autoref{eq:kkt}.

Note that the upper bound for the strong rule condition, the right-hand side of \autoref{eq:strong}, is smaller than the upper bound for the KKT condition inequality, i.e., $(1-\alpha)(2\lambda_s - \lambda_{s-1}) < (1-\alpha)(\lambda_{s-1})$, since $\lambda_{s} < \lambda_{s-1}$. We see from this that the strong rule condition, which is a condition on the subdifferential at $\lambda_{s-1}$, is stronger than the zero KKT condition at $\lambda_{s-1}$; the logic of the strong rule is that, if group $k$ satisfies the zero KKT condition at $\lambda_{s-1}$, with some wiggle room in the inequality, and if the function $c_k(\lambda)$ which characterizes the zero KKT condition does not change too much going from one lambda to the next, then the zero KKT will be satisfied for the next value $\lambda_s$.

Finally, we should reiterate that it is possible for the strong rule to make a mistake, the Lipschitz assumption is just that, an assumption. Because of this, it is critical that, after discarding some of the groups and running the algorithm on the others, the zero KKT condition is checked on all those discarded groups to make sure that the strong rule made the right decision, and that those groups are actually zero. Violators of the KKT condition should be put in 'active' status and the algorithm re-run with those groups included. The details of this are in the next section.

Now that we understand the KKT check and strong rule check on groups, we briefly discuss some notation which is used in the next section. In this section we defined a function $c_k(\lambda)$ that was parameterized by the group $k$ and taking in as an argument $\lambda$. We will change emphasis and define a function:
\[
\mathcal{S}_{\lambda}(A),
\]
that takes in a subset of the set of groups, $A$, and returns the set of all elements of $A$ which \textbf{fail} the strong rule check at $\lambda$. This is precisely the set of groups that we suspect of being active, that we should run the update step on. The reason why we want this notation is that it is a waste of time to run the strong rule check on those already known or suspected to be active. 

Similarly, we will define the function 
\[
KKT_{\lambda}(A)
\]
that takes in a  set of groups, and returns the subset of those elements of $A$ that \textbf{fail} the 0-KKT check, i.e. those elements $k \in A$ for which $\norm{c_k(\lambda)}_2 > (1-\alpha)\lambda$. Again, we do not need to check the KKT conditions for those groups on which the update step was run until convergence, so we will want to specify the subset of groups that we need to run the KKT check on after convergence of $U$.

\subsection{The four-step algorithms}

The algorithm called four-step algorithms in our package performs the sparse group lasso. This algorithm uses the majorized coordinate-descent update step $U$ from section 2.1, and the order of when it stores the active and potentially active groups guarantees the robustness when speeding up the computation. Before discussing it in detail, we need some notations and explanations.


First, recall from the end of the previous section that $\mathcal{S}_{\lambda}(A)$ is a function which performs the strong rule check on a set of groups $A$ at $\lambda$, and returns the set $A^{\prime}$ of groups in $A$ that fail the strong rule check. For each individual group in the set $A$, it checks the inequality in \autoref{eq:strong}. Recall that the strong rule check at a given $\lambda_k$ actually involves both $\lambda_{k}$ and $\lambda_{k-1}$; this is suppressed in this notation, with the consensus.

Similarly, the function $\textrm{KKT}_{\lambda} (A)$ performs the KKT check described in the previous section, and returns the subset $A^{\prime}$ of groups that fail the KKT check. The idea for both of these functions is to keep track of which groups are potentially active (nonzero) for the given $\lambda$. 

Both of these functions take in only a subset of the groups of coefficients, rather than being run on the whole set each time; this is to save time and reduce redundancy. It would not make sense to run a KKT check on those groups that are already known to be active (for the given $\lambda$), because the coordinate descent algorithm is guaranteed to converge for the groups on which is is run. Similarly for the strong rule check, it would be a waste of time to run that inequality on groups that are already known or suspected of being active, since the point of the strong rule check is to separate those suspected of being active from those that are not, and only updating the coefficient estimates for the suspected active groups.

We will keep track of active/potentially active groups with a set $\mathcal{E}$; this is the set of all groups that have failed the strong rule check, or have failed the KKT check, and it is precisely this set of groups that we perform the update step on until convergence. This set is ever-increasing, that is, if a group fails the strong rule or KKT check at some $\lambda_s$ and is put in $\mathcal{E}$, it stays in $\mathcal{E}$ for every subsequent $\lambda_{s+i}$. It is possible for a group to be active for some value of lambda and then become inactive later on in the lambda path, but this is unlikely, and we are not losing too much efficiency by making this group ever-increasing.

Finally, in the convergence step of the algorithms, we want to keep track of how much $\boldsymbol\beta$ is moving; if it appears to have found a minimum, and is not moving much from the update step, we want to declare convergence and kick out of the updating step. Because of this, we keep track of the maximum change in the $\boldsymbol\beta^{(k)}$'s with $\max_{k\in\mathcal{E}} \left(\norm{\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_i\}} - U\left(\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_i\}}\right)}\right)$. Once $\max_{k\in\mathcal{E}} \left(\norm{\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_i\}} - U\left(\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_i\}}\right)}\right) < \epsilon$, where $\epsilon$ is some pre-determined small amount, we move to the next step.


The highlight of four-step algorithm, \autoref{alg:fourStep} is that instead of adding groups into the 'active' set $\mathcal{E}$ before running the algorithm, the algorithm is first run until convergence on the original set $\mathcal{E}$, and the strong rule is run afterwards. The details are as follows.

\begin{algorithm}[tb!]
  \caption{The four-step Algorithm (revised)}
  \label{alg:fourStep}
  \begin{algorithmic}[1]
    \STATE Initialize $\boldsymbol{\lambda} = \{\lambda_s\}_{s = 1}^n$, and the corresponding coefficients at each $\lambda$ value $\{\hat{\boldsymbol{\beta}}_{\{\lambda_s\}}\}_{s = 1}^n$, where $n\in\mathbb{N}$.
    \STATE Let $\epsilon$ denote the convergence tolerance, $\mathcal{E}$ be the active set starting from an empty set, and $k$ indicate the groupings.
    \FOR{$s = 1, 2, \cdots, n$}
    \STATE Run through $\mathcal{E}$ (if not empty) until convergence:
    \bindent
    \WHILE{$\max_{k\in\mathcal{E}} \left(\norm{\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_s\}} - U\left(\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_s\}}\right)}\right) >\epsilon$}
    \bindent
    \STATE Update $\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_s\}}$ by $U\left(\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_s\}}\right)$ for all $\hat{\boldsymbol{\beta}}^{(k)}_{\{\lambda_s\}}\in\mathcal{E}$
    \eindent
    \ENDWHILE 
    \eindent
    \STATE Run strong rule check on inactive groups, then the KKT check on the violators:
    \bindent
    \IF {$KKT_{\lambda_s}(S_{\lambda_s}(\mathcal{E}^c))$}
    \bindent
    \STATE $\mathcal{E} \leftarrow \mathcal{E} \cup KKT_{\lambda_s}(S_{\lambda_s}(\mathcal{E}^c))$
    \STATE Return to Line 4.
    \eindent
    \ENDIF
    \eindent
    \STATE Run strong rule check on whole inactive set:
    \bindent
    \IF {$KKT_{\lambda_s}(\mathcal{E}^c)$}
    \bindent
    \STATE $\mathcal{E} \leftarrow \mathcal{E}\cup KKT_{\lambda_s}(\mathcal{E}^c)$
    \STATE Return to Line 4.
    \eindent
    \ENDIF
    \eindent
    \ENDFOR
    \RETURN{$\hat{\boldsymbol{\beta}} \leftarrow \{\hat{\boldsymbol{\beta}}_{\{\lambda_s\}}\}_{s = 1}^n$}
  \end{algorithmic}
\end{algorithm}


Assume we have solved the problem for $\lambda_{s-1}$. We loop over $\mathcal{E}$, which was passed over from $\lambda_{s-1}$, and update until convergence. The difference here is that we do not perform the strong check first. After we have run the update loop until convergence on the active set, we then perform the strong rule on the complement, $\mathcal{E}^c$. Since the strong rule depends on the computation of $\boldsymbol\beta_{\{\lambda_{s-1}\}}$, it doesn't actually matter whether the coefficients are converged or not. For any groups that fail the strong rule check, we run the KKT check; if there are any violators, put them in $\mathcal{E}$ and go back to step 1. Therefore, the difference is that the condition for adding groups to $\mathcal{E}$ is more stringent and is done after obtaining the converged coefficients. Otherwise, we run the KKT check on the full complement $\mathcal{E}^c$. Again, if there are any violators, we put them in $\mathcal{E}$ and go back to check if coefficients are diverged. If there are no violators, we are done, and we move on to the next $\lambda$ in the sequence.

In this algorithm, we are careful to put potentially active groups into the active set. Instead of putting groups in $\mathcal{E}$ immediately after applying the strong rule, we are hesitant to commit to running the algorithm on the strong rule alone. We run the strong rule after convergence, but then double-check that the suspected 'active' groups are actually so by using the KKT check.


# Example usage
This section provides a simple guidance for how to employ this package for fitting the regularization paths for sparse group-lasso penalized learning problems. We first import the sparsegl package, and start with a simulated regression dataset including an input matrix of predictors $\mathbf{X}$, a real-valued response vector $\mathbf{y}$, and a vector indicating the grouping structure:
```{r}
library(sparsegl)
```

```{r, data simulation}
set.seed(1010)
n <- 100
p <- 200
X <- matrix(data = rnorm(n*p, mean = 0, sd = 1), nrow = n, ncol = p)
eps <- rnorm(n, mean = 0, sd = 1)
beta_star <- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), c(2, -3, 8, 0, 0), 
               rep(0, (p - 20)))
y <- X %*% beta_star + eps
groups <- rep(1:(p / 5), each = 5)
```

To perform the regularization path fitting at a sequence of regularization parameters, \textbf{sparsegl()} consumes aforementioned $\mathbf{X}, \mathbf{y}$, the grouping vector \textbf{group}, and other main arguments such that users can assign them with different values rather than follow the default: a penalty vector \textbf{pf}, the weight of lasso penalty \textbf{asparse}, the lower and upper bounds for coefficient values \textbf{lower\_bnd} and \textbf{upper\_bnd}. This returns a \textbf{sparsegl} object and its associated attributes. One of the main attribute of this object, \textbf{df}, is a vector representing the number of nonzero coefficients at each $\lambda$ value and also an approximation to the exact degree-of-freedom.

```{r}
fit <- sparsegl(X, y, group = groups)
```

The affiliated functions to this fitted \textbf{sparsegl} object are \textbf{plot()},\textbf{coef()}, \textbf{predict()} and \textbf{print()}. Function textbf{plot()} either produces a coefficient profile plot of the coefficient paths to $\{\lambda_s\}_{s=1}^n$, or a group-norm plot against the penalties scaled by the max penalty value, in terms of the assignments to the arguments. Functions \textbf{coef()} and \textbf{predict()} computes the coefficients and predictions $\hat{\mathbf{y}}$ given a matrix $\tilde{\mathbf{X}}$ at the requested $\lambda$s' respectively, and the selection for $\lambda$ values different than the used sequence at the fitting stage is also allowed. Function \textbf{print()} returns the number of nonzero features with nonzero coefficients at each $\lambda$.

```{r, results = "hide", fig.show = "hide"}
plot(fit, y_axis = "coef", x_axis = "penalty", add_legend = FALSE)
plot(fit, y_axis = "group", x_axis = "lambda", add_legend = FALSE)
coef(fit, s = c(0.02, 0.03))
predict(fit, newx = X[100,], x = fit$lambda[2:3])
print(fit)
```

This package also supports for conducting a k-fold cross-validation with \textbf{cv.sparsegl()} given $\mathbf{X}, \mathbf{y}$, a vector \textbf{group} and an additional argument \textbf{pred.loss} indicating the loss to use for cross-validation error. This returns a fitted \textbf{cv.sparsegl} object. The affiliated functions are \textbf{plot()}, \textbf{coef()}, \textbf{predict()} for the \textbf{cv.sparsegl} object. Function \textbf{plot()} produces cross-validation curve with upper and lower confidence bounds plots for each $\lambda$ in the regularization path for the fitted \textbf{cv.sprasegl}. Functions \textbf{coef()} and \textbf{predict()} works similarly to those introduced above. The only differences are that they both consume \textbf{cv.sparsegl} objects, and the passed $\lambda$ values are also be \textbf{lambda.min} (the optimal $\lambda$ that gives the minimum mean cross-validation error) or \textbf{lambda.1se} (the largest $\lambda$ such that the error is within 1 standard error or the minimum).

```{r, results = "hide", fig.show = "hide"}
cv_fit <- cv.sparsegl(X, y, groups)
plot(cv_fit)
coef(cv_fit, s = c(0.02, 0.03))
predict(cv_fit, newx = X[50:60, ], s = "lambda.min")
```

For further detailed documentation and examples towards this package, it is recommended to look into this [website](https://dajmcdon.github.io/sparsegl/index.html).

# Comparisons with other packages

As we have stated in the beginning, \pkg{SGL} package is computationally inefficient when dealing with a high-dimensional optimization problem, while \pkg{gglasso} does not produce within-group sparsity during the modeling process. To verify that our package is time-saving and in the meanwhile, producing both within-group sparsity and between-group sparsity, we will repetitively generate regression datasets such that they include different sample sizes or a different number of features with or without within-group sparsity. In particular, we will evaluate and compare the time efficiency by \pkg{sparsegl}, \pkg{SGL} and \pkg{gglasso} for between-group sparsity cases, while \pkg{sparsegl}, \pkg{SGL} for including both between-group and within-group sparsity cases. The elapsed time (in milliseconds) will be measured using \pkg{microbenchmark}, and the results will be visualized with boxplots.

The approach to simulating models is as follows: for each dataset, we first generate an input matrix $\mathbf{X}$ by randomly sampling numbers from the standard normal distribution and converting them into a $n$-by-$p$ matrix, and the response vector is generated linearly by:
\begin{equation}
\mathbf{y} = \mathbf{X}\boldsymbol\beta^* + \boldsymbol\epsilon
\end{equation}
where the error term $\epsilon$ is also generated from the standard normal distribution as white noise, and the entries of coefficients vector $\boldsymbol\beta^*$ are zeros or nonzero, which is generated depending on whether within-group sparsity is considered. For the coefficients in the group $k$, all the entries of $\boldsymbol\beta^{*(k)}$ are zeros or nonzeros if the grouping structure is not within-group sparse, otherwise, $\boldsymbol\beta^{*(k)}$ could a subvector with a mixture of zero and nonzero values. We consider the following combinations of (n, p, within-group sparsity):

\begin{itemize}
\item $n = 100$, $p = 20, 60, 100, 200, 500$ and within-group sparsity exists.
\item $p = 100$, $n = 20, 60, 100, 200, 500$ and within-group sparsity exists.
\item $n = 100$, $p = 20, 60, 100, 200, 500$ and within-group sparsity not exists.
\item $p = 100$, $n = 20, 60, 100, 200, 500$ and within-group sparsity not exists.
\end{itemize}

For each combination, the elapsed time (in milliseconds) is recorded for fitting regularization path at 100 $\lambda$s' values by constructing models using \pkg{sparsegl}, \pkg{SGL} and \pkg{gglasso} in terms of the existence of within-group sparsity over 50 independent datasets. The boxplots illustrate the consumed time on each run.

Figure 1 incorporates all the cases above and plots the change in running time (in log scale) against different sample sizes $n$ or the number of features $p$. In all subplots, the running time of \pkg{SGL} is approximately linearly increasing when the sample size or the number of features increases, which is actually exponentially increasing, indicating that \pkg{SGL} could be enormously influenced by the dimensionality of the input matrix $X$ and the complexity of the problem. On the other hand, we can see that \pkg{sparsegl} and \pkg{gglasso} have roughly the same performance in computation efficiency and spend much less time in computing the solution paths. Particularly, in this example, both packages consume approximately the consistent time when the sample size $n$ increases, while require slowly-increasing time when the number of features $p$ increases. Therefore, \pkg{sparsegl} makes a significant improvement as compared to the existing packages that address sparse group-lasso high-dimensional optimization problems.

```{r, load packages, include=FALSE}
library(SGL)
library(gglasso)
library(sparsegl)

library(dplyr)
library(tidyr)
library(ggplot2)

library(microbenchmark)
```

```{r, functions, include = FALSE}
beta_generate <- function(p, within_group = TRUE, group_size) { 
  if (!within_group) {
    beta_star <- c(rep(5, 5), rep(-5, 5), c(2, -3, 8, 1, 3), c(5, -5, 2, -2, 1), 
                   rep(c(-5, 0, 1, 5), each = 5, times = (p - 20) / 20))
  } else {
    beta_star <- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), c(2, -3, 8, 0, 0), 
                   rep(c(rep(5, 5), rep(0, 5), rep(-5, 5), c(2, 3, 5, 0, 0)), times = (p - 20) / 20))
  }
  beta_star
}


simulate <- function(change_list,
                     change_feature = c("n", "p"), 
                     within_group = TRUE, 
                     group_size = 5) {
  change_feature <- match.arg(change_feature)
  df <- list()
  k <- 1
  
  if (change_feature == "n") {
    p <- 100
    beta_star <- beta_generate(p, within_group, group_size)
    groups <- rep(1:(p / group_size), each = group_size)
  } else {
    n <- 100
  }
  
  for (i in seq(length(change_list))) {
    if (change_feature == "n") {
      n <- change_list[i]
    } else {
      p <- change_list[i]
      beta_star <- beta_generate(p, within_group, group_size)
      groups <- rep(1:(p / group_size), each = group_size)
    }
    set.seed(123)
    X <- matrix(rnorm(n * p), nrow = n)
    for (j in seq(50)) {
      set.seed(j)
      eps <- rnorm(n)
      y <- X %*% beta_star + eps
      data <- list(x = X, y = y)
      if (!within_group) {
      df[[k]] <- as.data.frame(summary(
        microbenchmark(sparsegl = sparsegl(X, y, groups),
                       SGL = SGL(data, groups),
                       gglasso = gglasso(X, y, groups),
                       times = 1))) 
      } else {
        df[[k]] <- as.data.frame(summary(
          microbenchmark(sparsegl = sparsegl(X, y, groups),
                         SGL = SGL(data, groups), 
                         times = 1)))
      }
      
      df[[k]] <- df[[k]] %>% 
        select(expr, mean) %>% 
        mutate(!!change_feature := factor(!!rlang::sym(change_feature)))
      k <- k + 1
    }
  }
  datf <- bind_rows(df)
  return(datf)
}


plot_box <- function(datf, 
                     change_feature = c("n", "p")) {
  change_feature = match.arg(change_feature)
  if (change_feature == "n") {
    x_lab = "Sample size n"
  } else {
    x_lab = "Number of features p"
  }
  
  plot <- ggplot(datf, aes(x = !!rlang::sym(change_feature),
                   y = mean,
                   fill = expr)) +
    geom_boxplot(fatten = 0.5) +
    theme_bw() + 
    theme(legend.position = "bottom", legend.title = element_blank()) +
    ylab("Running time (ms)") +
    xlab(x_lab) +
    scale_fill_brewer(palette = "Set1") +
    scale_y_log10() 
  return(plot)
}
```

```{r, simulation, include = FALSE, eval = FALSE}
within_p <- simulate(change_list = c(20, 60, 100, 200, 500), change_feature = "p", within_group = TRUE, group_size = 5)
within_n <- simulate(change_list = c(20, 60, 100, 200, 500), change_feature = "n", within_group = TRUE, group_size = 5)
without_p <- simulate(change_list = c(20, 60, 100, 200, 500), change_feature = "p", within_group = FALSE, group_size = 5)
without_n <- simulate(change_list = c(20, 60, 100, 200, 500), change_feature = "n", within_group = FALSE, group_size = 5)

```

```{r, include = FALSE, eval = FALSE}
plot_box(datf_p, change_feature = "p")
ggsave("change_p_2.png")
plot_box(datf_n, change_feature = "n")
ggsave("change_n_2.png")

plot_box(datf_p_3, change_feature = "p")
ggsave("change_p_3.png")
plot_box(datf_n_3, change_feature = "n")
ggsave("change_n_3.png")

```

```{r, echo = FALSE, out.width="0.49\\linewidth", fig.show = "hold", fig.cap = "Running Time Comparison", fig.align = "center"}
knitr::include_graphics(c("change_p_2.png", "change_n_2.png"))
knitr::include_graphics(c("change_p_3.png", "change_n_3.png"))

# df <- data.frame(matrix(ncol = 2, nrow = 2))
# rownames(df) <- c("with within-group sparsity", "without within-group sparsity")
# colnames(df) <- c("by number of features p", "by sample size n")
# df
```



# Discussion and future work

(future: allows logistic regression models)

# Acknowledgements {.unnumbered}

Here we list all the packages that we needed to compile this code. \pkg{devtools} [@R-devtools] \pkg{usethis} [@R-usethis] \pkg{testthat} [@R-testthat] \pkg{knitr} [@R-knitr] \pkg{microbenchmark} [@R-microbenchmark] \pkg{ggplot2}[-@R-ggplot2] and \pkg{rticles} [-@R-rticles]. Also NSF and NSERC funding.
